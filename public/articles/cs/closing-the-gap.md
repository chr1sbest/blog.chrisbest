Closing the Gap
====
Making the jump from a self-taught novice *web developer* to a self-taught novice *software engineer*.

**Building a website is *easy*.**

Serving static content on the internet to whomever is unfortunate enough to type in the URL that maps to your server, is easy. Copy pasting javascript snippets at the end of your `<body`> section, crossing your fingers and praying to the [cargo-cult gods](http://en.wikipedia.org/wiki/Cargo_cult_programming) that your jQuery plugin will work, is easy. Writing blog articles about the relative ease of writing blog articles (**I**'m **s**o **m**eta, **e**ven **t**his **a**ssertion), is easy.

**Engineering scalable, reusable software solutions is not.**

**The Gap**
------
As a self-taught developer in the infancy of my career, the qualities I brought to the table were passion, determination, and an open mentality towards learning new ideas. Learning was painful. Every day was painful. Thankfully, I had enough passion and determination to pad my head while I constantly smashed it against the metaphorical wall of autodidactism. Eventually I was able to learn enough to convince a few employers that I was a competent web developer without suffering too much brain damage.

Could I build a website? Yeah! Was I a competent web developer? Haha! **No**. 

Sure, to an extent, it's important for a developer to be able to pick up new tools, fight through the pain of initial failures, and learn to use these tools to accomplish the task at hand. I was *great* at this! Back then, I would have even argued that this ability alone is what makes a competent software developer. Would I argue this now? **No.**

Why? After being exposed to the work of really good software engineers, I noticed a clear gap between a person that can learn to use tools and a person that understands how to **BUILD** tools. At it's core, **software engineering is about building scalable, reusable tools**. It's not about simply solving problems, it's about how you can structure your solutions in a manner that can scale to support millions/billions of customers while being able to function as a reusable tool for yourself and your colleagues.

But Chris, how did you learn to build these tools? If I learn how to use enough tools, will I learn the toolmakers thought process by some kind of magical osmosis? **Fuck no.**

**Becoming a Toolmaker**
-------
**All great toolmakers are "dwarves standing on the shoulders of giants."**

1.  1) There are a millions of people out there that are smarter than you and I.
2.  2) At least one of those people has built a tool to fix just about every problem imaginable.
3.  3) There are common ideas and patterns that exist in most of those tools.

There are brilliant people who have collected and documented these common tool-building practices and patterns, i.e. the [Gang of Four](http://en.wikipedia.org/wiki/Design_Patterns), [Donald Knuth](http://en.wikipedia.org/wiki/The_Art_of_Computer_Programming), etc. The secret to becoming a good toolmaker is to **find out who these people are, and then learn from them.**

**Plot Twist**: the most common tool-building practices happen to be taught in school as *fundamentals of computer science* and are typically requirements for computer science degrees. I'm talking data structures, algorithmic analysis, effective usage of recursion (tail-call optimization, memoization), object-oriented design patterns, interpreters/compilers, the functional programming paradigm, system architecture, etc. Turns out that there is reasoning to this curriculum. **Learning fundamentals of computer science will make you a better tool-maker.**

Fortunately, in the age we live in, all of this information can be found online. You're more than capable of finding it, but here are a few of the resources I've learned from:

1.  **1a) Data Structures? How about UC Berkeley's [CS61b](http://www.cs.berkeley.edu/~jrs/61b/)**
    * This course also has full recordings of lectures on youtube. Super useful in learning about common data structures, understanding when to use them, and learning how to implement them.
2.  **1b) Data Structures in [Python!](http://interactivepython.org/courselib/static/pythonds/index.html)**
    * Basically the same as above, without video, but in Python.
3.  **2a) Algorithmic Analysis? How about Princeton & Coursera's [Algorithms Pt.1](https://www.coursera.org/course/algs4partI)**
    * Everything you need to know about understanding best/worst/average case space and time complexity of common data structures.
4.  **2b) Algorithm Visualization in [D3](http://bost.ocks.org/mike/algorithms/)**
    * Beautiful and insightful representation of a few algorithms, useful as supplementary info to the course above.
5.  **3) OOP Design? [Youtube Series!](https://www.youtube.com/watch?v=vNHpsC5ng_E&list=PLF206E906175C7E07)**
    * Java implementations of all the Gang of Four's famous design patterns.
6.  **4a) What's an interpreter? [Peter Norvig](http://norvig.com/lispy.html) will tell you! **
    * Simple lisp interpreter.
7.  **4b) Mary Rose Cook's [Lisp Interpreter in Javascript](https://www.youtube.com/watch?v=hqnTvuvXPCc)**
    * Another simple lisp interpreter!

In learning how to build tools, not only do you start to produce better software, but it becomes even easier to pick up other people's tools and build them into even better tools, which is kinda what it's all about.

Never forget: Theoretical understanding is awesome, but to really cement any new software engineering knowledge, build something.

**Conclusion**
-----
I could have just written "the fundamentals of software engineering are the building blocks of skilled software engineering."

Oops.

Thanks for reading.
