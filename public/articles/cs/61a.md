UC Berkeley 61A: Structure and Interpretation of Computer Programs
===
---

Overview
---

** Overall Score: **
<span style="color: orange">
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star-half-full"></i>
</span>

** Course Cost: **: <span style="color: green; font-weight: bold">$1840</span> (or free!)

<a href="http://cs61a.org/">Course Website</a> UC Berkeley 61A course website

<hr>
<div class="imageWrapper">
</div>

In-Depth Review
---

**Usefulness: **
<span style="color: orange">
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star-half-full"></i>
</span>

There couldn't be a better introductory course for developing core fundamentals for a software engineer (i.e. **functional abstraction, lexical scoping, TESTING**, etc.) Two years into my career, in retrospect these ideas all seem simple and obvious -- this is beacause these fundamental concepts are so deeply rooted in my day to day work.

Python-specific syntactic sugar and shortcuts are introduced as a nice little bonus. Similar to passively picking up piano as you learn music theory -- you'll end up a decent Pythonista while learning computer science.

**Content: **
<span style="color: orange">
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star-o"></i>
</span>

Aside from the de-facto fundamentals of building software mentioned above, this course also introduces novel ideas and paradigms for solving problems. **Object oriented programming** is introduced and covered in depth, but equally, **functional programming** is introduced as an alternative means of solving problems and covered extensively. Ideas like parallelism, threading, big O notation, etc. are also briefly introduced but not extensively covered.

Also, a lot of mind-fucks. Be prepared.

My only knock on this course is that while it serves as the introductory course for computer science students, it is a weeder course. There is some material in this course that can be a little difficult to follow, but isn't necessary in the real world. In particular, if you're debugging lines of code like
```
list(map(str, map(grow, range(3, add(3)))))
```
you've got bigger problems than your understanding of functions being passed as arguments. 

**Lecture Quality: **
<span style="color: orange">
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
</span>

Production quality = A+. The lectures are pretty thorough, yet easy to digest. The little interactive stack trace debugger in the videos and in the reading material is pretty useful for exploration. John DeNero is a pretty funny guy too, so that helps.

**Resources: **
<span style="color: orange">
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star-o"></i>
</span>

<a href="http://composingprograms.com/">Composing Programs</a> - Main "textbook" for 61A.

<a href="http://norvig.com/lispy.html">Peter Norvig's Simple Lisp Interpreter in Python</a>

<a href="https://www.youtube.com/watch?v=hqnTvuvXPCc">Mary Rose Cook - Writing a Lisp Interpreter in Javascript</a>


**Conclusion**
---

100% recommend this course as an introductory course for computer science. However, I would recommend prior programming experience or at least going through the <a href="https://www.codecademy.com/en/tracks/python">Codeacademy Python Course</a> or <a href="http://learnpythonthehardway.org/">Learn Python the Hard Way</a> beforehand. While the course doesn't explicitly require Python knowledge, it will make it easier to focus on the core concepts when you don't need to worry about syntax or running a REPL.
